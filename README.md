# Grassland-Ecosystem-Simulation
A design for using the Data Structure knowledge. 

click the index.html then we can see the app.

Advantages: High performance, multi-strategy, intelligent.
Drawback: It does not implement multithreading and the effect is not intuitive.

A part of description of the project follows:

---

### 设计原则

##### 设计构想：

若想建立一个包含老虎、牛、草的模拟生态系统，我们面临以下的设计问题：

1. ##### **生态系统是离散的或是连续的？**

   1. 第一种想法是整个生态系统都是连续的。其优点在于生物的行动以向量作为引导，比较灵活和仿真。缺点在于生物的位置不特定，而其系统的驱动高度依赖于生成捕食、逃跑等向量和碰撞检测，这些往往需要遍历实现，以至于复杂度较高。除此之外其若在地图中添加障碍物，生物的行动的智能性将很难得到保证。

   2. 第二种想法是连续与离散并存的生态系统。其优点在于生物的行动仍然是以向量作为引导，比较灵活和仿真。除此之外其通过连续域网格化将生物划分到不同格子，利用图论知识进行广度优先搜索 (BFS) 等操作，理论上能有效降低复杂度和解决障碍物问题。缺点在于网格化的精度难以确定的，精度粗糙的网格会使广度优先搜索 (BFS) 等操作得到的结果存在较大误差，生物行为的智能性不能保证。而过于精细的网格实际并不能有效降低复杂度。

   3. 第三种想法是整个生态系统都是离散的。其优点在于行动方向较为简单，只有上、下、左、右四个方向。碰撞检测上也十分直接，==复杂度较低==。还可以利用图论知识实现广度优先搜索 (BFS)、最优广度优先搜索等操作，较为完美地解决障碍物问题，运用数据结构的知识。缺点在于仿真性有所下降，且生物的重叠问题需要解决。

      **我们选择的是第三种想法**，离散的生态系统。而为了补充生态系统的仿真性，我们建立了比较完备的生态系统机制和生物行动策略。对于生物重叠问题，我们借鉴了第二种想法，将地图进行网格化，每个格子作为一个对象可以存储多个生物予以解决这个问题。

2. **如何在离散设定中为观众展示较为连续的生物移动**

   ​	   由于离散设定，生态系统中的老虎速度必然要大于牛才可能通过“智能”而非运气来捕食牛。为此，假设牛每次只移动一个格，则老虎可能每次会移动两个格。但在UI端，老虎每次刷新就移动了两个格，对于观众而言，老虎的生物移动在视觉上是不连续的，很难跟踪一个特定目标捕捉到其“智能”所在。当速度更大时，这种不连续性更为显著。且由于单线程程序，牛和老虎的运行上必然不是同时的。观众可能会发现当某只牛明明下一步就要摆脱老虎的追捕了，但由于其运行顺序后于老虎，使其被老虎追上了。为了解决这种割裂感，我们尝试了多线程，但这常常会产生许多奇怪的bug。最终，我们将速度定义为了行动的抉择次数。每次行动可为移动一单位或停留在原地。因此老虎和牛虽然每次行动最多都是移动一单位，但是老虎行动的抉择次数多，总体可以移动更多的单位数。老虎和牛行动的抉择时机并非严格的轮流，我们为其设计了一个简单的规则/算法，称为“排班算法”。在UI刷新率较高的情况下，观众看到的老虎和牛几乎是同时移动的。



##### 核心假设：

1. 假设生态系统是离散的
2. 假设速度被定义为行动抉择的次数，及老虎和牛行动抉择的顺序符合我们设计的“排班算法”
3. 假设能量的积累会使空地重新变为草地，牛和老虎可以无性繁殖地生出幼崽。

---



##### 全局函数 Part 01

1. inside(x,y,m,n,p,q)：检测x，y坐标下的点是否符合$m<x<n$及$p<y<q$ 。
2. check_dir(x,y,dir)：判断在x，y坐标下像dir方向移动是否是合法的——即下一位置不越出边界，且非障碍物。
3. update_Weather()：判断当日的天气是Sun或Cloudy或Rain。晴天和雨天，草生长速度更快。阴天和雨天，牛和老虎每日固定消耗的能量更多。晴天和阴天下，牛和老虎行动的速度更快。

<br>

#### Super class —— species

**描述**：作为草、牛、老虎的父类，共用一些函数接口。

**函数**：

1. check() ：检测个体的age是否大于maxAge或energy是否小于等于0，若条件为真，设置个体的live属性为False，即该个体死了。在存活个体age加一之后会调用该函数，每一age仅会调用一次
2. checkEnergy() ：检测个体的energy是否小于等于0，若条件为真，设置个体的live属性为False，即该个体死了。在个体每次行动抉择完后会调用该函数，但若已经调用了check()则不会再调用checkEnergy()。因此每一age调用的次数等于个体行动抉择数-1。
3. move(type) : 个体每次移动必须要调用的函数，其根据个体的方向对个体的坐标进行更新，并且其根据参数type判断牛或老虎，扣除个体移动所需要消耗的能量代价。
4. random(type) ：随机选取一个方向设置为个体的方向，假若该方向的移动是合法的，则其调用move(type)移动。否则其在四个方向中任意选择一个方向作为起点，利用取模环形遍历四个方向搜索合法的移动方向，设置为个体方向后调用move(type)移动。



#### Son class —— Grass

**描述**：草地，草地与草地间不能重叠，草地的草死后变为空地。

**属性**：

1. id：整数值，作为primary key，通过其可以直接唯一识别且访问grasses动态数组中的特定Grass对象。
2. live：布尔值，True代表个体存活，False代表个体死亡，即为空地。
3. x，y：坐标
4. age：整数值，代表个体的年龄。
5. maxAge：整数值，代表个体的最大寿命。
6. energy：浮点数，代表个体当前的能量。倘若个体无其余的能量消耗，该能量值会随age的变化在fullEnergy和maxEnergy间呈现先增后减的二次函数，以表现个体从成长期到衰退期的变化。
7. fullEnergy：浮点数，代表个体基值能量，也是初始化个体所拥有的能量。
8. maxEnergy：浮点数，代表个体的最大能量上限。
9. cost_of_prey：浮点数，代表吃草所需要花费的能量，可认为是咀嚼所需要的能量。牛若低于该能量则不能吃草。
10. gain_of_prey：浮点数，代表吃草后所能获得的能量。

**函数**：

1. add()：为创建的新的Grass对象赋予id，用类静态属性number实现。
2. beLive()：在空地变为草地的时候我们将死去的对象（空地）重新初始化作为新的对象（草地），会调用该函数。
3. GrassReproduce()：如果该个体是死亡的，其现积累的能量以及达到了从空地变为草地的标准，则调用beLive()函数让其变为草地。
4. tick()：每一age都会调用一次，对存活个体而言，其age增加1，且在其现有能量基础上增加因为成长所增加或减去衰退所扣除的能量。操作后调用check()检测个体是否死亡，若死亡则将其energy设为0。对于死亡个体，即空地而言，在其现有能量基础上增加当前天气所积累的成长能量。


<br>
#### Son class —— Cow

**描述**：牛，牛和牛之间可以存在于同一个地图的单元格中，牛吃草，老虎吃牛。

**属性**：

1. id：整数值，作为primary key，通过其可以直接唯一识别且访问cows动态数组中的特定Cow对象。
2. live：布尔值，True代表个体存活，False代表个体死亡。
3. x，y：坐标
4. age：整数值，代表个体的年龄。
5. maxAge：整数值，代表个体的最大寿命。
6. energy：浮点数，代表个体当前的能量。倘若个体无其余的能量消耗，该能量值会随age的变化在fullEnergy和maxEnergy间呈现先增后减的二次函数，以表现个体从成长期到衰退期的变化。
7. fullEnergy：浮点数，代表个体基值能量，也是初始化个体所拥有的能量。
8. maxEnergy：浮点数，代表个体的最大能量上限。
9. dailyEnergy_Sun：浮点数，代表个体在晴天下每一age固定消耗的能量。
10. dailyEnergy_Cloudy_Rain：浮点数，代表个体在阴天和雨天下每一age固定消耗的能量。
11. speed：整数值，行动的抉择次数。
12. maxSpeed：整数值，最大行动抉择次数。
13. cost_of_prey：浮点数，代表吃牛所需要花费的能量，可认为是与牛搏斗所需要的能量。老虎若低于该能量则不能吃牛。
14. gain_of_prey：浮点数，代表吃牛后所能获得的能量。
15. reproduceAge_lowerBound：整数值，代表个体最低繁殖年龄，即个体age要大于该年龄才能繁殖。
16. reproduceAge_upperBound：整数值，代表个体最高繁殖年龄，即个体age要低于年龄才能繁殖。
17. reproduceNum：整数值，记录该个体已经繁殖了多少幼崽，该值存在上限。
18. dir：枚举值，代表上、下、左、右四个方向之一。

**函数**：

1. add()：为创建的新的Cow对象赋予id，用类静态属性number实现。
2. beLive()：后文会提到我们将死去的对象的id储存在一个==Free List==中，而在原始数组中用live属性作为“墓碑”机制假性标记他“被删除”。在诞生新幼崽的时候我们用Linked List中的remove()函数获取死去的对象的id，将该死去的对象重新初始化作为新的对象，会调用该函数。
3. CowReproduce()：当存活个体的age处于繁殖年龄的区间，且能量达到了繁殖的能量要求，其有一定的受孕概率能够产生一个新的幼崽在其周围。
4. eatGrass(grass)：个体吃掉grass对象，更新个体的能量，grass对象的存活状态及能量设为0。
5. moveToGrass(grass_cluster,cow_cluster)：我们借鉴了数据结构中secondary index的想法，建立一个低精度的地图，该地图记录了各个区域内草、牛的数量，即grass_cluster和cow_cluster。当个体处于温饱状态下，概率调用该函数。其代表个体不满足于现在的局部，向每只牛平均拥有最多草的区域进行探索。
6. CowEscapce()：个体搜索临近的位置。如果存在老虎，部分迟钝的个体选择无视，而绝大多数的个体会提起警觉，搜索附近更大范围的位置是否存在老虎，并把他们的信息记录下来。将个体与各个老虎间的向量加总，取远离老虎且向量投影大的方向逃跑。如果已经逃跑至地图边界且逃跑向量仍然指向边界，逃跑向量会经过旋转矩阵的线性投影换方向逃跑。
7. CowFindGrass()：个体通过BFS搜索最近的草。如果草的位置与个体位置相距不超过一个单位，则移动到草的位置并吃掉它。否则依照路径向草的位置移动。虽然路径不会保持到下一个行动抉择，但每次BFS都一定能保证现在去往的是最近的草。如果两次BFS的结果不同，代表第一次BFS的草现已不是最优的选择了。BFS的拓展节点数存在上限，即其为局部的广度优先搜索。若未能搜到，其会调用moveToGrass(grass_cluster,cow_cluster)。
8. tick()：每一age都会调用一次，对存活个体而言，其age增加1，且在其现有能量基础上增加因为成长所增加或减去衰退所扣除的能量和减去每一age固定消耗的能量。操作后调用check()检测个体是否死亡。

<br>

#### Son class —— Tiger

**描述**：老虎，老虎和老虎之间可以存在于同一个地图的单元格中，老虎吃牛。

**属性**：

1. id：整数值，作为primary key，通过其可以直接唯一识别且访问tigers动态数组中的特定Tiger对象。
2. live：布尔值，True代表个体存活，False代表个体死亡。
3. x，y：坐标
4. age：整数值，代表个体的年龄。
5. maxAge：整数值，代表个体的最大寿命。
6. energy：浮点数，代表个体当前的能量。倘若个体无其余的能量消耗，该能量值会随age的变化在fullEnergy和maxEnergy间呈现先增后减的二次函数，以表现个体从成长期到衰退期的变化。
7. fullEnergy：浮点数，代表个体基值能量，也是初始化个体所拥有的能量。
8. maxEnergy：浮点数，代表个体的最大能量上限。
9. dailyEnergy_Sun：浮点数，代表个体在晴天下每一age固定消耗的能量。
10. dailyEnergy_Cloudy_Rain：浮点数，代表个体在阴天和雨天下每一age固定消耗的能量。
11. speed：整数值，行动的抉择次数。
12. maxSpeed：整数值，最大行动抉择次数。
13. reproduceAge_lowerBound：整数值，代表个体最低繁殖年龄，即个体age要大于该年龄才能繁殖。
14. reproduceAge_upperBound：整数值，代表个体最高繁殖年龄，即个体age要低于年龄才能繁殖。
15. reproduceNum：整数值，记录该个体已经繁殖了多少幼崽，该值存在上限。
16. dir：枚举值，代表上、下、左、右四个方向之一。

**函数**：

1. add()：为创建的新的Tiger对象赋予id，用类静态属性number实现。
2. beLive()：后文会提到我们将死去的对象的id储存在一个==Free List==中，而在原始数组中用live属性作为“墓碑”机制假性标记他“被删除”。在诞生新幼崽的时候我们用Linked List中的remove()函数获取死去的对象的id，将该死去的对象重新初始化作为新的对象，会调用该函数。
3. TigerReproduce()：当存活个体的age处于繁殖年龄的区间，且能量达到了繁殖的能量要求，其有一定的受孕概率能够产生一个新的幼崽在其周围。
4. eatCow(cow)：个体吃掉cow对象，更新个体的能量，cow对象的存活状态及能量设为0。
5. moveToCow(cow_cluster,tiger_cluster)：我们借鉴了数据结构中secondary index的想法，建立一个低精度的地图，该地图记录了各个区域内牛、老虎的数量，即cow_cluster和tiger_cluster。当个体处于温饱状态下，概率调用该函数。其代表个体不满足于现在的局部，向每只老虎平均拥有最多牛的区域进行探索。
6. TigerBFS()：个体通过BFS搜索最近的牛。如果牛的位置与个体位置相距不超过一个单位，则移动到草的位置并吃掉它。否则依照路径向草的位置移动。虽然路径不会保持到下一个行动抉择，但每次BFS都一定能保证现在去往的是最近的牛。如果两次BFS的结果不同，代表第一次BFS的牛现已不是最优的选择了。BFS的拓展节点数存在上限，即其为局部的广度优先搜索。若未能搜到，其会调用moveToCow(cow_cluster,tiger_cluster)。
7. tick()：每一age都会调用一次，对存活个体而言，其age增加1，且在其现有能量基础上增加因为成长所增加或减去衰退所扣除的能量和减去每一age固定消耗的能量。操作后调用check()检测个体是否死亡。

<br>

#### class grid：

**描述**：高精度地图中每一个单元格，储存对于的一块草地/空地，一些牛和一些老虎。

**属性**：

1. x，y：坐标
2. tempCows：一棵Binary Search Tree(BST)，储存在这个单元格内cow的id。
3. tempTigers：一棵Binary Search Tree(BST)，储存在这个单元格内tiger的id。
4. type：标记这个单元格是否是障碍物。

---



### 复杂度分析

Suppose the number of grasses is k, the number of cows is n, the number of tiger is m.

##### 总体功能：

1. 初始化，依照参数调用排班算法。	$O(1)$

2. 如果是新的一年，设置新的天气，重置行动计数器    $O(1)$

3. 如果按照排班，轮到牛进行行动抉择，则遍历每一只牛    $O(n)$

   1. 如果是存活的牛

      1. 牛概率保持惯性，继续以上一次的方向进行移动，保持策略的持续性。	$O(logn)$
      2. 牛搜索邻近区域发现有老虎，其大概率选择躲避老虎们的追击。    $O(m)$
      3. 牛的能量如果大于温饱线
         1. 其概率选择继续寻找最近的草吃以达到更高的能量。——保守者/贪心者    $O(logn)$
         2. 其概率选择在原地停留以避免移动带来的能量损耗。——安逸者    $O(1)$
         3. 其概率选择随机移动，闲逛一下。——安逸者    $O(logn)$
         4. 其概率选择向牛均草更多的地方进发、探索。——探索者    $O(logn)$
      4. 牛的能量如果小于温饱线，牛寻找最近的草吃。    $O(logn)$

      如果是年末，调用时钟功能更新age，减去固定消耗的能量等操作。否则检查个体能量是否小于零，更新个体存活状态。繁殖。    $O(logn)$

4. 如果按照排班，轮到老虎进行行动抉择，则遍历每一只老虎    $O(m)$

   1. 如果是存活的老虎

      1. 老虎概率保持惯性，继续以上一次的方向进行移动，保持策略的持续性。    $O(logm)$
      2. 老虎的能量如果大于温饱线
         1. 其概率选择继续寻找牛吃以达到更高的能量。——保守者/贪心者    $O(logm+logn)$
         2. 其概率选择在原地停留以避免移动带来的能量损耗。——安逸者    $O(1)$
         3. 其概率选择随机移动，闲逛一下。——安逸者    $O(logm)$
         4. 其概率选择向虎均牛更多的地方进发、探索。——探索者    $O(logm)$
      3. 老虎的能量如果小于温饱线
         1. 老虎用BFS寻找最近的牛吃。——现实者    $O(logm+logn)$
         2. 老虎用基于优先队列的最优BFS寻找最优的牛吃。——理想者    $O(logm+logn)$

      如果是年末，调用时钟功能更新age，减去固定消耗的能量等操作。否则检查个体能量是否小于零，更新个体存活状态。繁殖。    $O(logm)$

5. 如果按照排班，轮到草行动，则遍历每一片草地    $O(K)$

   1. 调用时钟功能更新age，进行能量更新等操作，更新个体存活状态。繁殖。    $O(1)$

6. 行动计数器自增1，回到步骤2 



值得注意的是，我们对BFS等算法的拓展节点总数都进行了限界，因此其计算复杂度视为$O(1)$。而每次移动由于要先删除grid内的牛或老虎再加入到另一grid中，这涉及到grid类BST属性的插入与删除，因此计算复杂度为$O(logn)$或$O(logm)$。

假设每个分支的概率都均等，以简化计算。

$Total  Complexity=O(1)+O(1)$

$+O(n)\times(\frac{O(logn)}{4}+\frac{O(m)}{4}+\frac{\frac{O(logn)}{4}+\frac{O(1)}{4}+\frac{O(logn)}{4}+\frac{O(logn)}{4}}{4}+\frac{O(logn)}{4}+O(logn))$

$+O(m)\times(\frac{O(logm)}{3}+\frac{\frac{O(logm+logn)}{4}+\frac{O(1)}{4}+\frac{O(logm)}{4}+\frac{O(logm)}{4}}{3}+\frac{\frac{O(logm+logn)}{2}+\frac{O(logm+logn)}{2}}{3}+O(logm))$

$+O(k)\times O(1)$

$=O(nlogn)+O(nm)+O(mlogm)+O(k)$




##### 附属功能：

通过选择物种的type和具体的id可以查询个体的坐标、存活状态、年龄、当前的能量和方向等参数，并在地图中标记其位置。

---



### Model

**数据结构知识：**

1. **Linked Queue：**在BFS中，需要使用数据结构queue来储存拓展的节点。原先我们采用的是Java Script动态数组中自带的shift()函数代替队列的pop()，但是shift()复杂度为$O(n)$。由于每次搜索的拓展节点数不均衡，因此我们选择了不固定长度的Linked Queue，通过改写，pop()操作复杂度降为$O(1)$，性能大大改进。
2. **Linked List：**正如前文所提到的，死去的对象都会存入该对象所属类的Free List中。deadGrassId、deadCowId、deadTigerId原先我们采用的是Java Script的动态数组，随机选取一个位置进行splice()的操作，其复杂度为$O(n)$。我们实现了Linked List进行改写，用remove()将操作复杂度降为$O(1)$，性能大大改进。
3. **Binary Search Tree:** 对于每个grid中，我们需要储存在这个单元格内的牛和老虎的id，分别储存在tempCows和tempTigers中。由于生物的移动是频繁的，即总会有一个单元格delete该个体的id，另一个单元格insert该个体的id。除此之外生物的死亡与死亡对象复苏也是频繁的，即总会有一个单元格delete该个体的id，另一个单元格insert该个体的id。可见delete和insert操作的配比近乎等于1:1。原先我们对于tempCows和tempTigers使用的是Java Script的动态数组。delete和insert的组合操作复杂度为$O(n)+O(1)=O(n)$。经过深入的思考，我们用BST进行了改写，delete和insert的组合操作复杂度降为$O(log n)+O(log n)=O(log n)$。由于该组合操作的频繁性，当n较大时，程序性能大大改进。
4. **Heap：**用于作为优先队列。其能长久地维护有顺序的数据，且由于其是完全平衡的二叉树和拥有链表一样的灵活增删数据的特性，使用Heap的方案时间复杂度上要优于动态数组+二分查找进行插入和删除的方案。插入和remove的时间复杂度为严格的$O(logn)$
5. **BFS：**在离散地图中使用Linked Queue储存待拓展节点以进行广度搜索。在每步代价一致的情况下BFS具有完备性，其必然能找到当前状态下最近距离的牛或草。我们还为BFS搜索树的节点设置了parent属性，因此我们在搜索至目标节点后能反向搜索最短路径。由此，BFS被用于老虎追捕牛和牛寻找草源的一种策略。除此之外，为了避免BFS无限拓展，我们设置了拓展的最高节点数以划定范围，当无目标节点时更换策略。在实际过程中，由于我们要重复利用一块map来储存节点是否被访问过，我们在搜索过程中还需要用need_recover来记录进入过Linked Queue中的节点以在搜索后重置节点状态。
6. **A*：**我们使用了基于优先队列的BFS，严格意义上其不完全等价于A*算法。其f(n)函数并不由g(n)和h(n)构成，仅使用了grid类中的cow_smell属性作为节点的评估函数。cow_smell为牛走过留下的信息素气味，年龄越大的牛留下的气味越多，这符合科学研究。每次都通过Heap弹出最优节点以进行拓展和搜索。
7. **Secondary map：**我们借鉴了secondary index的思想，我们在move_to_cow和move_to_grass上需要产生全局的信息。由于这一信息只是用作方向性引导，不需要过于具体，因此我们构造了多层次的地图系统。我们建立了一个secondary map这一低精度的地图，设计了一个映射规则能将高精度的地图映射至低精度的地图，将老虎、牛、草聚类。由此符合需求地大大降低了算法的复杂度。

